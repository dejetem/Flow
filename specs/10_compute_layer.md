# Flow Compute Layer

## Role & Goals

Provides a secure, decentralized, verifiable, and efficient execution fabric for agent/user-initiated computational tasks (e.g., ML inference, simulation, data transformation, verification).

Aims for:
*   **Local-first Execution:** Default to running tasks locally when possible.
*   **Verifiable Compute:** Generate cryptographic proofs of correct execution.
*   **Privacy-Preserving:** Support computation on encrypted or sensitive data.
*   **Incentivized Compute:** Integrate with the Incentive Layer for rewarding providers.
*   **Intent-Driven:** Execute tasks based on clear specifications (MCP, DAGs).
*   **Heterogeneous Support:** Run tasks across diverse environments (local, peer, enclave, network).

## Architecture Components

*   **Runners:** The actual execution environments that run task code.
*   **Schedulers/Dispatchers:** Match tasks to appropriate Runners based on requirements and policy. (Interaction with Execution Layer's Task Dispatcher).
*   **Resource Managers:** Track provider capabilities and availability.
*   **Verification Oracles/Services:** Validate proofs generated by Runners.
*   **Compute Marketplaces (Optional):** Facilitate discovery and negotiation with external compute providers.

Integrates with:
*   Execution Layer (receives tasks, returns results/proofs)
*   KG/MCP Layer (retrieves model/tool manifests, context)
*   Storage Layer (accesses input data, stores output data/proofs)
*   Network Layer (communicates with remote runners/providers)
*   Incentive Layer (handles payments/rewards for compute)
*   Access & Auth Layer (enforces permissions for task execution)

## Execution Models Supported

Dynamically selected based on policy (trust, resources, privacy, cost, location):
*   **Local Execution:** Run directly on the user's/agent's machine.
*   **Remote Peer Execution:** Delegate task to a trusted peer via P2P network.
*   **Secure Enclave Execution (TEE):** Run tasks in hardware-isolated Trusted Execution Environments (e.g., Intel SGX, ARM TrustZone) for confidentiality and integrity.
*   **Distributed Compute Network Execution:** Offload tasks to external networks (e.g., Bacalhau, Golem) via adapters.
*   **Scheduled Execution:** Trigger tasks based on time or specific events.
*   **Reactive Execution:** Trigger tasks based on agent SLRPA cycle or context changes.
*   **Multi-Stage DAG Execution:** Coordinated execution of dependent tasks (managed primarily by Execution Layer, utilizing Compute Layer for individual task runs).

## Providers & Marketplaces

*   Abstracts different sources of compute:
    *   Local Host
    *   Trusted Peers (via P2P network)
    *   Secure Enclaves (local or remote)
    *   Private Clusters
    *   Decentralized Marketplaces (e.g., Bacalhau)
*   Providers declare capabilities (resources like CPU/GPU/RAM, privacy features like TEE/zkVM support, pricing models, reputation scores) via signed profiles.
*   VCs gate delegation of tasks to specific providers.
*   Integrates payment/incentive models (tokens, credits, reputation boosts) via Incentive Layer.

## Task Definition & Packaging

*   Uses **Task Manifests** (often derived from or part of MCP manifests):
    *   Signed, CID-addressable (DAG-JSON/CBOR).
    *   Specifies:
        *   MCP references for models/tools.
        *   Inputs (CIDs, graph queries, DAG task refs).
        *   Outputs (expected format, storage location).
        *   Runtime requirements (WASM module, OCI image, specific hardware).
        *   Constraints (privacy level, region locks, proof requirements, cost budget, deadlines).
        *   VC authorizing the execution.
*   Supports packaging formats:
    *   Raw DAG structures
    *   CAR files (for bundled dependencies)
    *   OCI (Docker) images
    *   WASM modules
    *   Proof Bundles (task + required proofs)

## Model/Tool Integration (via MCP)

*   Leverages **Model Context Protocol (MCP)** manifests.
*   Handles model/tool invocation across different execution modes.
*   Manages input binding and context injection based on MCP requirements.
*   Handles output processing (linking results to KG, packaging proofs).
*   Enforces policies defined in MCP (privacy, consent).
*   Generates detailed execution traces linked to the MCP manifest.
*   Supports versioning and reproducibility.

## Secure Execution Environments

*   Provides pluggable, sandboxed runtimes:
    *   **WASM:** For portable, secure code execution.
    *   **TEEs (SGX, TrustZone):** Hardware-based isolation for confidentiality and integrity, enabling remote attestation.
    *   **zkVMs (Zero-Knowledge Virtual Machines):** Generate proofs of correct execution for specific computations.
    *   **OCI Containers (Docker):** For legacy or complex dependencies (with appropriate sandboxing).
    *   **VM Isolation:** Traditional virtual machine sandboxing.
*   Enforces task policies (resource limits, network access, proof requirements, data sealing).
*   Runtime selection driven by task sensitivity, resource needs, proof requirements, cost, and policy.
*   Generates verifiable audit trails and proofs/attestations.

## Privacy-Preserving Computation Techniques

Integrates techniques based on task requirements and policy:
*   **Homomorphic Encryption (HE/FHE):** Compute on encrypted data.
*   **Zero-Knowledge Proofs (ZKPs):** Including zkML/zkDL for proving ML inference/training properties without revealing inputs/models.
*   **Trusted Execution Environments (TEEs):** Hardware protection for computation.
*   **Secure Multi-Party Computation (MPC):** Distribute computation across multiple parties without revealing inputs.
*   **Differential Privacy:** Add noise to outputs to protect individual input privacy.
*   Governed by task policies, VC-based consent, and linked to compliance tags in the KG.

## Proof of Execution & Verifiability

*   Core feature ensuring compute was performed correctly and without tampering.
*   Supports multiple proof types:
    *   **Signatures + Hashes:** Basic integrity check.
    *   **Remote Attestations:** Proof from TEEs about the executed code and platform state.
    *   **ZK Proofs:** Succinct proofs of computational integrity (zkPoE, zkML).
    *   **Multi-Hop Provenance:** Verifiable trace linking inputs, compute steps, outputs, and executor identity (via DAG/graph trace).
    *   **Encrypted/Sealed Logs:** Tamper-evident logs generated during execution.
*   Standard proof record format links inputs (CIDs), outputs (CIDs), executor DID, proof type, proof data (CID), and signature.
*   Includes checks for policy compliance (e.g., privacy constraints met).
*   Enables replay/regeneration of proofs where applicable.
*   Links proofs to the KG provenance graph.

## Resource Metering & Cost Accounting

*   Tracks resource consumption (CPU time, memory usage, I/O, GPU usage, network bandwidth, proof generation overhead).
*   Providers generate signed metering logs.
*   Task manifests can specify cost models (budget limits, preferred rates, settlement mechanisms).
*   Integrates with payment channels (wallets, token contracts, VC-based credits) via the Incentive Layer.
*   Supports verifiable metering through audits, ZK proofs, or consensus mechanisms.
*   Helps prevent abuse via budget caps and reputation penalties.
*   Informs scheduling decisions.

## Error Handling

*   Defines standard formats and error codes for compute tasks to report runtime failures back to the Execution Layer.
*   Includes errors like timeouts, resource exhaustion, code exceptions, policy violations, input/output errors.
*   Enables robust failure handling within DAG execution logic.

## Scheduling Interaction

*   While the Execution Layer's Task Dispatcher handles DAG-level scheduling, the Compute Layer manages:
    *   Provider discovery and capability matching.
    *   Bid negotiation (for marketplace providers).
    *   Internal queuing and management for tasks assigned to its runners (especially for scheduled/reactive tasks).
*   Provides necessary feedback (availability, estimated cost, compliance status) to the Execution Layer Dispatcher.

## Observability

*   Provides standard interfaces/hooks for compute tasks/runners to expose detailed operational metrics and structured logs (e.g., OpenTelemetry compatible).
*   Goes beyond basic metering/provenance to facilitate enhanced debugging, monitoring, and performance analysis.
